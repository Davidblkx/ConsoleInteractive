{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ConsoleInteractive About ConsoleInteractive is a netstandard2 library that make it easy to parse and validate data from the console. It provide methods to request data in all basic C# types, and allow to create new input types Why When I create small command line tools I kept rewriting input parse and validation, and despite great tools to parse arguments and to print output, I didn't find anything that could help me do it. Install You can install it using nuget: dotnet add package ConsoleInteractive --version 2.0.1 <PackageReference Include=\"ConsoleInteractive\" Version=\"2.0.1\" /> Install-Package ConsoleInteractive -Version 2.0.1 Register default components: ConsoleI.RegisterDefaults() How-to start The easiest way to start using it is to clone the repo and see how the ConsoleInteractive.Demo is built, or by exploring this documentation","title":"Home"},{"location":"#consoleinteractive","text":"","title":"ConsoleInteractive"},{"location":"#about","text":"ConsoleInteractive is a netstandard2 library that make it easy to parse and validate data from the console. It provide methods to request data in all basic C# types, and allow to create new input types","title":"About"},{"location":"#why","text":"When I create small command line tools I kept rewriting input parse and validation, and despite great tools to parse arguments and to print output, I didn't find anything that could help me do it.","title":"Why"},{"location":"#install","text":"You can install it using nuget: dotnet add package ConsoleInteractive --version 2.0.1 <PackageReference Include=\"ConsoleInteractive\" Version=\"2.0.1\" /> Install-Package ConsoleInteractive -Version 2.0.1 Register default components: ConsoleI.RegisterDefaults()","title":"Install"},{"location":"#how-to-start","text":"The easiest way to start using it is to clone the repo and see how the ConsoleInteractive.Demo is built, or by exploring this documentation","title":"How-to start"},{"location":"console-i/","text":"ConsoleI Description ConsoleI is the principal object for all input request Methods AskConfirmation User must press key to accept of reject Signature: bool AskConfirmation(string message, ConsoleKey okKey = ConsoleKey.Y, ConsoleKey koKey = ConsoleKey.N) Params: message -> message to show as question okKey -> ConsoleKey to use as true koKey -> ConsoleKey to use as false Details: User must press one of two keys to continue, one returns true , other false By default keys are Y -> true, N -> false Ask Receives text input from console and converts to type Signature: Task<T> Ask<T>(string message, T defaultValue = default, IValidatorCollection<T>? validators = null, StringConverterProvider? provider = null) Params: message -> message to show before request input defaultValue -> value to use as default if no input validators -> input validators provider -> input converter provider Details: Allow to request input using free text, A default value can be passed. You can pass a collection of validators, that will force the user to input a expected value You can pass a custom converter provider to convert result Read more at: InputText Validators Converters Select User must select from a list of values Signature: // select one Task<T> Select<T>(IEnumerable<T> options); // select one or more Task<IEnumerable<T>> Select<T>(IEnumerable<T> options, int max); // select one from enum type Task<T> Select<T>() where T : Enum; // select one or more from enum type Task<IEnumerable<T>> Select<T>(int max) where T : Enum; Params: options -> collection of options to show max -> max number of selected options allowed Details: User must always select at least one option You can pass a collection of validators, that will force the user to input a expected value You can pass a custom converter provider to convert result Read more at: InputSelect Validators Converters Form Build object from multi questions, using FormEntry attribute Signature: Task<T> RenderForm<T>() where T : new() Details: T must have properties with attribute FormEntry Read more at: Form","title":"ConsoleI"},{"location":"console-i/#consolei","text":"","title":"ConsoleI"},{"location":"console-i/#description","text":"ConsoleI is the principal object for all input request","title":"Description"},{"location":"console-i/#methods","text":"","title":"Methods"},{"location":"console-i/#askconfirmation","text":"User must press key to accept of reject Signature: bool AskConfirmation(string message, ConsoleKey okKey = ConsoleKey.Y, ConsoleKey koKey = ConsoleKey.N) Params: message -> message to show as question okKey -> ConsoleKey to use as true koKey -> ConsoleKey to use as false Details: User must press one of two keys to continue, one returns true , other false By default keys are Y -> true, N -> false","title":"AskConfirmation"},{"location":"console-i/#ask","text":"Receives text input from console and converts to type Signature: Task<T> Ask<T>(string message, T defaultValue = default, IValidatorCollection<T>? validators = null, StringConverterProvider? provider = null) Params: message -> message to show before request input defaultValue -> value to use as default if no input validators -> input validators provider -> input converter provider Details: Allow to request input using free text, A default value can be passed. You can pass a collection of validators, that will force the user to input a expected value You can pass a custom converter provider to convert result Read more at: InputText Validators Converters","title":"Ask"},{"location":"console-i/#select","text":"User must select from a list of values Signature: // select one Task<T> Select<T>(IEnumerable<T> options); // select one or more Task<IEnumerable<T>> Select<T>(IEnumerable<T> options, int max); // select one from enum type Task<T> Select<T>() where T : Enum; // select one or more from enum type Task<IEnumerable<T>> Select<T>(int max) where T : Enum; Params: options -> collection of options to show max -> max number of selected options allowed Details: User must always select at least one option You can pass a collection of validators, that will force the user to input a expected value You can pass a custom converter provider to convert result Read more at: InputSelect Validators Converters","title":"Select"},{"location":"console-i/#form","text":"Build object from multi questions, using FormEntry attribute Signature: Task<T> RenderForm<T>() where T : new() Details: T must have properties with attribute FormEntry Read more at: Form","title":"Form"},{"location":"adv/converter/","text":"Input Conversion 1. About Most data user inputs in a terminal is in string format, in order to allow for flexibility and to support complex types there are multiple ways to allow that conversion. Use types that implement IConvertible , works for every common language runtime type. Have type implement IStringConverter<T> , valid in most situation Register a IStringConverter<T> for a specific type in a StringConverterProvider 2. IStringConverter Interface to be implement by types to allow conversion from and to string. It could be used in 2 ways 1. Self implement: public class Person : StringConverter<Person> { public string Name { get; set; } public int Age { get; set; } public Person(): base(PersonToString, StringToPerson) { } public static string PersonToString(Person p) => $\"{p.Name}:{p.Age}\"; public static Person StringToPerson(string s) { var data = s.Split(':'); return new Person { Name = data[0], Age = int.Parse(data[1]) }; } } 2. Register a converter: public class Person { public string Name { get; set; } public int Age { get; set; } public Person() { } public static string PersonToString(Person p) => $\"{p.Name}:{p.Age}\"; public static Person StringToPerson(string s) { var data = s.Split(':'); return new Person { Name = data[0], Age = int.Parse(data[1]) }; } } // Register in a provider var converter = new StringConverter<Person>(Person.PersonToString, Person.StringToPerson); StringConverterProvider.Global.Register(converter); 3. StringConverter Provider A StringConverterProvider is a class that allows to register and retrieve IStringConverter for a type. By default is used the StringConverterProvider.Global instance, so if a converter is supposed to be reused, it should be register here. Registration example: var converter = new StringConverter<Person>(Person.PersonToString, Person.StringToPerson); StringConverterProvider.Global.Register(converter); 4. Factory When it's time to convert a input, the StringConverterFactory is used to create the IStringConverter for the target type. To Create a converter the factory tries to get it following the steps: Current Provider ( StringConverterProvider.Global by default) Self implementation, if type implements IStringConverter IConvertible if type implements it Throw an Exception","title":"Conversion"},{"location":"adv/converter/#input-conversion","text":"","title":"Input Conversion"},{"location":"adv/converter/#1-about","text":"Most data user inputs in a terminal is in string format, in order to allow for flexibility and to support complex types there are multiple ways to allow that conversion. Use types that implement IConvertible , works for every common language runtime type. Have type implement IStringConverter<T> , valid in most situation Register a IStringConverter<T> for a specific type in a StringConverterProvider","title":"1. About"},{"location":"adv/converter/#2-istringconverter","text":"Interface to be implement by types to allow conversion from and to string. It could be used in 2 ways 1. Self implement: public class Person : StringConverter<Person> { public string Name { get; set; } public int Age { get; set; } public Person(): base(PersonToString, StringToPerson) { } public static string PersonToString(Person p) => $\"{p.Name}:{p.Age}\"; public static Person StringToPerson(string s) { var data = s.Split(':'); return new Person { Name = data[0], Age = int.Parse(data[1]) }; } } 2. Register a converter: public class Person { public string Name { get; set; } public int Age { get; set; } public Person() { } public static string PersonToString(Person p) => $\"{p.Name}:{p.Age}\"; public static Person StringToPerson(string s) { var data = s.Split(':'); return new Person { Name = data[0], Age = int.Parse(data[1]) }; } } // Register in a provider var converter = new StringConverter<Person>(Person.PersonToString, Person.StringToPerson); StringConverterProvider.Global.Register(converter);","title":"2. IStringConverter"},{"location":"adv/converter/#3-stringconverter-provider","text":"A StringConverterProvider is a class that allows to register and retrieve IStringConverter for a type. By default is used the StringConverterProvider.Global instance, so if a converter is supposed to be reused, it should be register here. Registration example: var converter = new StringConverter<Person>(Person.PersonToString, Person.StringToPerson); StringConverterProvider.Global.Register(converter);","title":"3. StringConverter Provider"},{"location":"adv/converter/#4-factory","text":"When it's time to convert a input, the StringConverterFactory is used to create the IStringConverter for the target type. To Create a converter the factory tries to get it following the steps: Current Provider ( StringConverterProvider.Global by default) Self implementation, if type implements IStringConverter IConvertible if type implements it Throw an Exception","title":"4. Factory"},{"location":"adv/forms/","text":"Forms About Sometimes we need build a object from multiple interactions with the user, to make it easier Forms is the solution, by adding the attribute FormEntry to the properties required to retrieve, it's easy to build an object. Example Class with attributes and validations public class TestFormClass { public const string REQUIRED = \"TEXT_REQUIRED\"; public const string AGE_INTERVAL = \"AGE_INTERVAL\"; public const string WORK_TITLES_COMPONENT = \"WORK_TITLES_ENUM_COMPONENT\"; public TestFormClass() { /* For demo purposes validators and components are register at the constructor In real world, would be better to do it at start up, or before the first call */ // Validation for string ValidatorProvider.Global.Register(REQUIRED, ValidatorCollection .Create<string>().Add(s => (s.Length > 0, \"Can't be empty\"))); // Validation for uint ValidatorProvider.Global.Register(AGE_INTERVAL, ValidatorCollection .Create<uint>() .Add(n => (n >= 13, \"Age must be older than 13\")) .Add(n => (n <= 150, \"Age must be younger then 150\")) ); // Register a custom component with name <WORK_TITLES_COMPONENT> ComponentsProvider.Global.Register(WORK_TITLES_COMPONENT, InputSelection.FromEnum<WorkTitles>()); } [FormEntry(Priority = 0, Message = \"Insert name\", ValidatorsKey = REQUIRED)] public string Name { get; set; } [FormEntry(Priority = 1, Message = \"Insert age\", ValidatorsKey = AGE_INTERVAL)] public uint Age { get; set; } [FormEntry(Priority = 2, Message = \"Select work\", ProviderKey = WORK_TITLES_COMPONENT)] public WorkTitles WorkTitle { get; set; } // Enum public override string ToString() { return $\"{Name} ({Age}) => {string.Join(';', WorkTitle.ToString())}\"; } } Calling input for class TestFormClass data = await ConsoleForm.BuildForm<TestFormClass>().Request();","title":"Forms"},{"location":"adv/forms/#forms","text":"","title":"Forms"},{"location":"adv/forms/#about","text":"Sometimes we need build a object from multiple interactions with the user, to make it easier Forms is the solution, by adding the attribute FormEntry to the properties required to retrieve, it's easy to build an object.","title":"About"},{"location":"adv/forms/#example","text":"","title":"Example"},{"location":"adv/forms/#class-with-attributes-and-validations","text":"public class TestFormClass { public const string REQUIRED = \"TEXT_REQUIRED\"; public const string AGE_INTERVAL = \"AGE_INTERVAL\"; public const string WORK_TITLES_COMPONENT = \"WORK_TITLES_ENUM_COMPONENT\"; public TestFormClass() { /* For demo purposes validators and components are register at the constructor In real world, would be better to do it at start up, or before the first call */ // Validation for string ValidatorProvider.Global.Register(REQUIRED, ValidatorCollection .Create<string>().Add(s => (s.Length > 0, \"Can't be empty\"))); // Validation for uint ValidatorProvider.Global.Register(AGE_INTERVAL, ValidatorCollection .Create<uint>() .Add(n => (n >= 13, \"Age must be older than 13\")) .Add(n => (n <= 150, \"Age must be younger then 150\")) ); // Register a custom component with name <WORK_TITLES_COMPONENT> ComponentsProvider.Global.Register(WORK_TITLES_COMPONENT, InputSelection.FromEnum<WorkTitles>()); } [FormEntry(Priority = 0, Message = \"Insert name\", ValidatorsKey = REQUIRED)] public string Name { get; set; } [FormEntry(Priority = 1, Message = \"Insert age\", ValidatorsKey = AGE_INTERVAL)] public uint Age { get; set; } [FormEntry(Priority = 2, Message = \"Select work\", ProviderKey = WORK_TITLES_COMPONENT)] public WorkTitles WorkTitle { get; set; } // Enum public override string ToString() { return $\"{Name} ({Age}) => {string.Join(';', WorkTitle.ToString())}\"; } }","title":"Class with attributes and validations"},{"location":"adv/forms/#calling-input-for-class","text":"TestFormClass data = await ConsoleForm.BuildForm<TestFormClass>().Request();","title":"Calling input for class"},{"location":"adv/validation/","text":"Validation 1. About In order to validate user input, you need to create validators. Validators are lambdas that return a boolean with a success status and a message of the reason to fail. They could be represent by: (T e) => (bool, string?) 2. Validator<T> In order to allow Generics usage and more flexibility, validators are build from the class Validator<T> . And by default all validators are treated as a Task . A validator that check if the user inputted an empty text, could be written as: var validator = new Validator<string>(e => (!string.IsNullOrEmpty(e), \"Can't be empty\")) Async validators are also accepted, actually all validators are treated as async. An async validator could be written as: var validator = new Validator<string>(async e => (await LongCall(e), \"LongCall failed to validate input\")) 3. Exceptions Sometimes returning a message for each error in a long validator could be laborious, so it's possible to write a method that report errors by throwing an Exception with a custom message. By default all exception are handled, but if the Exception ValidatorException is thrown the full message is shown instead of a default one. Example output: throw new Exception(\"Invalid length\") => \"Error validating input: Invalid Length\" throw new ValidatorException(\"Invalid length\") => \"Invalid Length\" 4. Collection The best way to represent a series of validations is using the ValidatorCollection<T> , it allows to aggregate multiple validators and when validates an Input it keeps the insert order. Collections are also the main way to run a validation, which mean that most interaction is done through this object. An example of a collection that could check an input password: var validators = ValidatorCollection .Create<string>() .Add(e => (e.Length >= 8, \"Length must be at least 8\")) .Add(e => (e.Length < 64, \"Length must be less than 64\")) .Add(async e => (await CheckPwnedPassword(e), \"Password has appear in a data breach\")); var (valid, errorMessage) = validators.ValidateInput(password); 5. ValidatorProvider A ValidatorProvider is a way to reference a ValidatorCollection<T> by name, which allow to call validation for an input without even knowing the type. It also allow to use Enum as a name and Flags to aggregate multiple collection. Every time a provider is required and none is available, the default ValidatorProvider.Global is used. Register a collection and validate inputs: var validators = ValidatorCollection .Create<string>() .Add(e => (e.Length >= 8, \"Length must be at least 8\")) .Add(e => (e.Length < 64, \"Length must be less than 64\")) .Add(async e => (await CheckPwnedPassword(e), \"Password has appear in a data breach\")); ValidatorProvider.Global.Register<string>(\"PASSWORD\", validators); // It can be used in any moment by var (valid, errorMessage) = await ValidatorProvider.Global.Validate(\"PASSWORD\", password); Using Enums: [Flags] enum StringValidator { NotEmpty = 1, MinLength3 = 2, MinLength7 = 4, Lowercase = 8, } ValidatorProvider.Global.Register( StringValidator.NotEmpty, ValidatorCollection.Create<string>() .Add(e => (!string.IsNullOrEmpty(e), \"Can't be empty\"))); ValidatorProvider.Global.Register( StringValidator.MinLength3, ValidatorCollection.Create<string>() .Add(e => (e.Length >= 3, \"Length must be at least 3\"))); ValidatorProvider.Global.Register( StringValidator.MinLength7, ValidatorCollection.Create<string>() .Add(e => (e.Length >= 7, \"Length must be at least 7\"))); ValidatorProvider.Global.Register( StringValidator.Lowercase, ValidatorCollection.Create<string>() .Add(e => (e == e.ToLower(), \"Must be in lowercase\"))); var validator = StringValidator.MinLength7 | StringValidator.Lowercase; // Check that input has min length 7 and is in lowercase var (valid, errorMessage) = await ValidatorProvider.Global.Validate(validator, input);","title":"Validation"},{"location":"adv/validation/#validation","text":"","title":"Validation"},{"location":"adv/validation/#1-about","text":"In order to validate user input, you need to create validators. Validators are lambdas that return a boolean with a success status and a message of the reason to fail. They could be represent by: (T e) => (bool, string?)","title":"1. About"},{"location":"adv/validation/#2-validatort","text":"In order to allow Generics usage and more flexibility, validators are build from the class Validator<T> . And by default all validators are treated as a Task . A validator that check if the user inputted an empty text, could be written as: var validator = new Validator<string>(e => (!string.IsNullOrEmpty(e), \"Can't be empty\")) Async validators are also accepted, actually all validators are treated as async. An async validator could be written as: var validator = new Validator<string>(async e => (await LongCall(e), \"LongCall failed to validate input\"))","title":"2. Validator&lt;T>"},{"location":"adv/validation/#3-exceptions","text":"Sometimes returning a message for each error in a long validator could be laborious, so it's possible to write a method that report errors by throwing an Exception with a custom message. By default all exception are handled, but if the Exception ValidatorException is thrown the full message is shown instead of a default one. Example output: throw new Exception(\"Invalid length\") => \"Error validating input: Invalid Length\" throw new ValidatorException(\"Invalid length\") => \"Invalid Length\"","title":"3. Exceptions"},{"location":"adv/validation/#4-collection","text":"The best way to represent a series of validations is using the ValidatorCollection<T> , it allows to aggregate multiple validators and when validates an Input it keeps the insert order. Collections are also the main way to run a validation, which mean that most interaction is done through this object. An example of a collection that could check an input password: var validators = ValidatorCollection .Create<string>() .Add(e => (e.Length >= 8, \"Length must be at least 8\")) .Add(e => (e.Length < 64, \"Length must be less than 64\")) .Add(async e => (await CheckPwnedPassword(e), \"Password has appear in a data breach\")); var (valid, errorMessage) = validators.ValidateInput(password);","title":"4. Collection"},{"location":"adv/validation/#5-validatorprovider","text":"A ValidatorProvider is a way to reference a ValidatorCollection<T> by name, which allow to call validation for an input without even knowing the type. It also allow to use Enum as a name and Flags to aggregate multiple collection. Every time a provider is required and none is available, the default ValidatorProvider.Global is used. Register a collection and validate inputs: var validators = ValidatorCollection .Create<string>() .Add(e => (e.Length >= 8, \"Length must be at least 8\")) .Add(e => (e.Length < 64, \"Length must be less than 64\")) .Add(async e => (await CheckPwnedPassword(e), \"Password has appear in a data breach\")); ValidatorProvider.Global.Register<string>(\"PASSWORD\", validators); // It can be used in any moment by var (valid, errorMessage) = await ValidatorProvider.Global.Validate(\"PASSWORD\", password); Using Enums: [Flags] enum StringValidator { NotEmpty = 1, MinLength3 = 2, MinLength7 = 4, Lowercase = 8, } ValidatorProvider.Global.Register( StringValidator.NotEmpty, ValidatorCollection.Create<string>() .Add(e => (!string.IsNullOrEmpty(e), \"Can't be empty\"))); ValidatorProvider.Global.Register( StringValidator.MinLength3, ValidatorCollection.Create<string>() .Add(e => (e.Length >= 3, \"Length must be at least 3\"))); ValidatorProvider.Global.Register( StringValidator.MinLength7, ValidatorCollection.Create<string>() .Add(e => (e.Length >= 7, \"Length must be at least 7\"))); ValidatorProvider.Global.Register( StringValidator.Lowercase, ValidatorCollection.Create<string>() .Add(e => (e == e.ToLower(), \"Must be in lowercase\"))); var validator = StringValidator.MinLength7 | StringValidator.Lowercase; // Check that input has min length 7 and is in lowercase var (valid, errorMessage) = await ValidatorProvider.Global.Validate(validator, input);","title":"5. ValidatorProvider"},{"location":"comps/custom/","text":"Custom Components About Its possible to create custom components, for that we only need to extend the abstract class BaseInputRender<T> and implement the method Task<T> RequestInput() . Then we can register it in the InputRenderProvider just like any other component Example public class InputText<T> : BaseInputRender<T> { public Type Target => typeof(T); /// <summary> /// Message to show before requesting input /// </summary> /// <value></value> public string Message { get; set; } /// <summary> /// Default value to use if no input /// </summary> /// <value></value> public object? DefaultValue { get; set; } public InputText() { Message = $\"Input value for a {Target}\"; } public override async Task<T> RequestInput() { const string BUFFER_NAME = \"#INTERNAL.COMPONENT.TEXTINPUT.TOP\"; // Write message with default value Console.WriteLine(BuildMessage()); // Save current console position ConsoleBuffer.MemoriseBufferPosition(BUFFER_NAME); T ToObject(string v) => GetConverter().ToObject(v); while (true) { try { var res = Console.ReadLine(); var data = (string.IsNullOrEmpty(res), DefaultValue is null) switch { (false, _) => ToObject(res), // is not empty (true, false) => (T)DefaultValue!, // empty but has default value (_, _) => ToObject(\"\") // empty without default value }; var (valid, message) = await Validators.ValidateInput(data); if (!valid) throw new Exception(message ?? \"Error validating input\"); // return converted input return data; } catch (Exception ex) { // Write to console Console.WriteLine(ex.Message + \",\\nPress [Return] to retry...\"); // Wait user confirmation Console.ReadKey(); // Clear input and return to question ConsoleBuffer.ClearBufferFrom(BUFFER_NAME); } } } private string BuildMessage() { var converter = GetConverter(); var defaultVal = DefaultValue is null ? \"\" : $\"({converter.ToString(DefaultValue)})\"; return $\"{Message} {defaultVal}\"; } }","title":"Custom"},{"location":"comps/custom/#custom-components","text":"","title":"Custom Components"},{"location":"comps/custom/#about","text":"Its possible to create custom components, for that we only need to extend the abstract class BaseInputRender<T> and implement the method Task<T> RequestInput() . Then we can register it in the InputRenderProvider just like any other component","title":"About"},{"location":"comps/custom/#example","text":"public class InputText<T> : BaseInputRender<T> { public Type Target => typeof(T); /// <summary> /// Message to show before requesting input /// </summary> /// <value></value> public string Message { get; set; } /// <summary> /// Default value to use if no input /// </summary> /// <value></value> public object? DefaultValue { get; set; } public InputText() { Message = $\"Input value for a {Target}\"; } public override async Task<T> RequestInput() { const string BUFFER_NAME = \"#INTERNAL.COMPONENT.TEXTINPUT.TOP\"; // Write message with default value Console.WriteLine(BuildMessage()); // Save current console position ConsoleBuffer.MemoriseBufferPosition(BUFFER_NAME); T ToObject(string v) => GetConverter().ToObject(v); while (true) { try { var res = Console.ReadLine(); var data = (string.IsNullOrEmpty(res), DefaultValue is null) switch { (false, _) => ToObject(res), // is not empty (true, false) => (T)DefaultValue!, // empty but has default value (_, _) => ToObject(\"\") // empty without default value }; var (valid, message) = await Validators.ValidateInput(data); if (!valid) throw new Exception(message ?? \"Error validating input\"); // return converted input return data; } catch (Exception ex) { // Write to console Console.WriteLine(ex.Message + \",\\nPress [Return] to retry...\"); // Wait user confirmation Console.ReadKey(); // Clear input and return to question ConsoleBuffer.ClearBufferFrom(BUFFER_NAME); } } } private string BuildMessage() { var converter = GetConverter(); var defaultVal = DefaultValue is null ? \"\" : $\"({converter.ToString(DefaultValue)})\"; return $\"{Message} {defaultVal}\"; } }","title":"Example"},{"location":"comps/input-sel/","text":"Input Select Component About Component that allow user to select from a list of values Examples Select one from a list var selection = InputSelection.From<TestClass>() .AddOption(new TestClass { Name = \"option1\" }) .AddOption(new TestClass { Name = \"option2\" }) .AddOption(new TestClass { Name = \"option3\" }) .AddOption(new TestClass { Name = \"option4\" }); TestClass result1 = await selection.RequestInput().First(); Multi select var selection2 = InputSelection.From<TestClass>() .SetMaxSelected(5) .AddOption(new TestClass { Name = \"option1\" }) .AddOption(new TestClass { Name = \"option2\" }) .AddOption(new TestClass { Name = \"option3\" }) .AddOption(new TestClass { Name = \"option4\" }) .AddOption(new TestClass { Name = \"option5\" }) .AddOption(new TestClass { Name = \"option6\" }) .AddOption(new TestClass { Name = \"option7\" }) .AddOption(new TestClass { Name = \"option8\" }) .AddOption(new TestClass { Name = \"option9\" }) .AddOption(new TestClass { Name = \"option10\" }) .AddOption(new TestClass { Name = \"option11\" }); IEnumerable<TestClass> result2 = await selection2.RequestInput(); Using an Enum EnumTest result3 = await InputSelection .FromEnum<EnumTest>() .RequestInput() .First();","title":"InputSelect"},{"location":"comps/input-sel/#input-select-component","text":"","title":"Input Select Component"},{"location":"comps/input-sel/#about","text":"Component that allow user to select from a list of values","title":"About"},{"location":"comps/input-sel/#examples","text":"","title":"Examples"},{"location":"comps/input-sel/#select-one-from-a-list","text":"var selection = InputSelection.From<TestClass>() .AddOption(new TestClass { Name = \"option1\" }) .AddOption(new TestClass { Name = \"option2\" }) .AddOption(new TestClass { Name = \"option3\" }) .AddOption(new TestClass { Name = \"option4\" }); TestClass result1 = await selection.RequestInput().First();","title":"Select one from a list"},{"location":"comps/input-sel/#multi-select","text":"var selection2 = InputSelection.From<TestClass>() .SetMaxSelected(5) .AddOption(new TestClass { Name = \"option1\" }) .AddOption(new TestClass { Name = \"option2\" }) .AddOption(new TestClass { Name = \"option3\" }) .AddOption(new TestClass { Name = \"option4\" }) .AddOption(new TestClass { Name = \"option5\" }) .AddOption(new TestClass { Name = \"option6\" }) .AddOption(new TestClass { Name = \"option7\" }) .AddOption(new TestClass { Name = \"option8\" }) .AddOption(new TestClass { Name = \"option9\" }) .AddOption(new TestClass { Name = \"option10\" }) .AddOption(new TestClass { Name = \"option11\" }); IEnumerable<TestClass> result2 = await selection2.RequestInput();","title":"Multi select"},{"location":"comps/input-sel/#using-an-enum","text":"EnumTest result3 = await InputSelection .FromEnum<EnumTest>() .RequestInput() .First();","title":"Using an Enum"},{"location":"comps/input-text/","text":"Input Text Component About Component that receives free text input and converts it to a specific type. Examples // Simple string to string input var inputText = InputText.Create<string>(\"Write something\"); var strQ = await inputText.RequestInput(); // Expects a number input, defaults to 10 if empty var inputNum = InputText.Create(\"Write a number\", 10L); long numQ = await inputNum.RequestInput(); // Expects a number between 10 and 50 var validatorMinMax = ValidatorCollection.Create<int>() .Add(l => (l > 10, \"Value must be higher than 10\")) .Add(l => (l < 50, \"Value must be less than 50\")); var inputInt = InputText.Create(\"Write a number between 10 and 50\", 0, validatorMinMax); var intQ = await inputInt.RequestInput();","title":"InputText"},{"location":"comps/input-text/#input-text-component","text":"","title":"Input Text Component"},{"location":"comps/input-text/#about","text":"Component that receives free text input and converts it to a specific type.","title":"About"},{"location":"comps/input-text/#examples","text":"// Simple string to string input var inputText = InputText.Create<string>(\"Write something\"); var strQ = await inputText.RequestInput(); // Expects a number input, defaults to 10 if empty var inputNum = InputText.Create(\"Write a number\", 10L); long numQ = await inputNum.RequestInput(); // Expects a number between 10 and 50 var validatorMinMax = ValidatorCollection.Create<int>() .Add(l => (l > 10, \"Value must be higher than 10\")) .Add(l => (l < 50, \"Value must be less than 50\")); var inputInt = InputText.Create(\"Write a number between 10 and 50\", 0, validatorMinMax); var intQ = await inputInt.RequestInput();","title":"Examples"},{"location":"comps/provider/","text":"InputRenderProvider About InputRenderProvider is where we can register and call register components. It allows to call a component by name or by an enum, its the way FormRender uses to pick the right render for a field Register a component InputRenderProvider","title":"InputRenderProvider"},{"location":"comps/provider/#inputrenderprovider","text":"","title":"InputRenderProvider"},{"location":"comps/provider/#about","text":"InputRenderProvider is where we can register and call register components. It allows to call a component by name or by an enum, its the way FormRender uses to pick the right render for a field","title":"About"},{"location":"comps/provider/#register-a-component","text":"InputRenderProvider","title":"Register a component"}]}